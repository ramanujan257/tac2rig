%{
#include <iostream>
#include <string>
#include <vector>
#define YYDEBUG 1

#include "basic_blocks.hpp"

void yyerror(std::string s){
    std::cerr << s << std::endl;
    exit(EXIT_FAILURE);
}

extern int yylex();

std::vector<BasicBlock*> basicBlocks;
BasicBlock* currBB = new BasicBlock();

BasicBlock* getCurrentBB(){
    return currBB;
}

void setCurrentBB(BasicBlock* bb){
    currBB = bb;
}

BasicBlock* bbLookup(int address){
    for(auto b : basicBlocks){
        for(auto l : b->getLines()){
            if(std::stoi(l.line()) == address)
                return b;
        }
    }
    
    return nullptr;
}

%}

%union {
    int n;
    std::string* s;
    BasicBlock* b;
}

%token<n> num_token
%token<s> id_token
%token goto_token if_token
%type<s> Linija E

%left '<' '='
%left '+' '-'
%left '*'

%%
Program: Program Linija '\n' {
            //std::cout << "Program nl Linija" << std::endl;
            getCurrentBB()->addLine(*$2);
        }
        |Linija '\n' {
            //std::cout << "Linija" << std::endl;
            getCurrentBB()->addLine(*$1);
        }
        ;

Linija: num_token ':' id_token ':' '=' E {
            $$ = new std::string(std::to_string($1) + ":" + *$3 + ":=" + *$6);
            }
       | num_token ':' id_token '[' id_token ']' ':' '=' E {
            $$ = new std::string(std::to_string($1) + ":" + *$3 + "[" + *$5 + "]:=" + *$9);
       }
       | num_token ':' if_token E goto_token '(' num_token ')' {
        
            BasicBlock* curr = getCurrentBB();
            BasicBlock* elseBB = new BasicBlock();
            basicBlocks.push_back(elseBB);
            curr->addChild(elseBB);
            elseBB->addParent(curr);
            BasicBlock* thenBB = bbLookup($7);
            if(!thenBB){
                thenBB = new BasicBlock();
                basicBlocks.push_back(thenBB);
            }
            curr->addChild(thenBB);
            thenBB->addParent(curr);
       
            $$ = new std::string(std::to_string($1) + ": if " + *$4 + " goto B" + std::to_string(thenBB->getID())); 

            setCurrentBB(elseBB);
       }
       ;

E: E '+' E {
        $$ = new std::string(*$1 + "+" + *$3);
    }
    | E '-' E {
        $$ = new std::string(*$1 + "-" + *$3);
    }
    | E '*' E {
        $$ = new std::string(*$1 + "*" + *$3);
    }
    | E '<' '=' E {
        $$ = new std::string(*$1 + "<=" + *$4);
    }
    | id_token {
        $$ = $1;
    }
    | num_token {
        $$ = new std::string(std::to_string($1));
    }
    ;

%%

int main(){

//  yydebug = 1;
	basicBlocks.push_back(currBB);

    yyparse();

	BasicBlock* exitBB = new BasicBlock();

	for (int i=0; i<basicBlocks.size(); i++) {
		std::vector<BasicBlock*> children = basicBlocks[i]->getChildren();
		
		bool exit = true;
		for (auto c : children) {
			auto found = std::find(basicBlocks.cbegin(),
								   basicBlocks.cbegin()+i, c);
			if (found != basicBlocks.cend()) {
				exit = false;
			}
		}
		
		if (exit) basicBlocks[i]->addChild(exitBB);
	}

	for (auto b : basicBlocks) {
		std::cout << "B" << b->getID() << ":\n";
		for (Line l : b->getLines()) {
			std::cout << l.line() << std::endl;
		}
		
		auto children = b->getChildren();
		auto found = std::find(children.cbegin(), children.cend(), exitBB);
		if (found != children.cend()) {
			std::cout << "->Exit" << std::endl;
		}

		std::cout << std::endl;
	}

    return 0;
}
