%{
#include <iostream>
#include <string>
#include <vector>
#define YYDEBUG 1

#include "basic_blocks.hpp"

void yyerror(std::string s){
    std::cerr << s << std::endl;
    exit(EXIT_FAILURE);
}

void la(const std::vector<BasicBlock*>& bbs);

extern int yylex();

std::vector<BasicBlock*> basicBlocks;
BasicBlock* currBB = new BasicBlock();
int exit_id;

BasicBlock* getCurrentBB(){
    return currBB;
}

void setCurrentBB(BasicBlock* bb){
    currBB = bb;
}

BasicBlock* bbLookup(int address){
    for(auto b : basicBlocks){
        for(auto l : b->getLines()){
            if(std::stoi(l.line()) == address)
                return b;
        }
    }
    
    return nullptr;
}

%}

%union {
    int n;
    std::string* s;
    BasicBlock* b;
}

%token<n> num_token
%token<s> id_token
%token goto_token if_token
%type<s> Linija E

%left '<' '='
%left '+' '-'
%left '*'

%%
Program: Program Linija '\n' {
            //std::cout << "Program nl Linija" << std::endl;
            getCurrentBB()->addLine(*$2);
        }
        |Linija '\n' {
            //std::cout << "Linija" << std::endl;
            getCurrentBB()->addLine(*$1);
        }
        ;

Linija: num_token ':' id_token ':' '=' E {
            $$ = new std::string(std::to_string($1) + ":" + *$3 + ":=" + *$6);
            }
       | num_token ':' id_token '[' id_token ']' ':' '=' E {
            $$ = new std::string(std::to_string($1) + ":" + *$3 + "[" + *$5 + "]:=" + *$9);
       }
       | num_token ':' if_token E goto_token '(' num_token ')' {
        
            BasicBlock* curr = getCurrentBB();
            BasicBlock* elseBB = new BasicBlock();
            basicBlocks.push_back(elseBB);
            curr->addChild(elseBB);
            elseBB->addParent(curr);
            BasicBlock* thenBB = bbLookup($7);
            if(!thenBB){
                thenBB = new BasicBlock();
                basicBlocks.push_back(thenBB);
            }
            curr->addChild(thenBB);
            thenBB->addParent(curr);
       
            $$ = new std::string(std::to_string($1) + ": if " + *$4 + " goto B" + std::to_string(thenBB->getID())); 

            setCurrentBB(elseBB);
       }
       ;

E: E '+' E {
        $$ = new std::string(*$1 + "+" + *$3);
    }
    | E '-' E {
        $$ = new std::string(*$1 + "-" + *$3);
    }
    | E '*' E {
        $$ = new std::string(*$1 + "*" + *$3);
    }
    | E '<' '=' E {
        $$ = new std::string(*$1 + "<=" + *$4);
    }
    | id_token {
        $$ = $1;
    }
    | num_token {
        $$ = new std::string(std::to_string($1));
    }
    ;

%%

int main(){

//  yydebug = 1;
	basicBlocks.push_back(currBB);

    yyparse();

	BasicBlock* exitBB = new BasicBlock();
	exit_id = exitBB->getID();

	for (int i=0; i<basicBlocks.size(); i++) {
		std::vector<BasicBlock*> children = basicBlocks[i]->getChildren();
		
		bool exit = true;
		for (auto c : children) {
			auto found = std::find(basicBlocks.cbegin(),
								   basicBlocks.cbegin()+i, c);
			if (found != basicBlocks.cend()) {
				exit = false;
			}
		}
		
		if (exit) basicBlocks[i]->addChild(exitBB);
	}

	la(basicBlocks);

	for (auto b : basicBlocks) {
		std::cout << "B" << b->getID() << ":\n";
		std::cout << "in[B" << b->getID() << "] = {";
		b->print_in();
		std::cout << "}; out[B" << b->getID() << "] = {";
		b->print_out();
		std::cout << "}\n\n";
		for (Line l : b->getLines()) {
			std::cout << l.line() << "\t{";
			l.print_use();
			std::cout << "}{";
			l.print_def();
			std::cout << "}\n";
		}
		
		auto children = b->getChildren();
		auto found = std::find(children.cbegin(), children.cend(), exitBB);
		if (found != children.cend()) {
			std::cout << "->Exit" << std::endl;
		}

		std::cout << std::endl;
	}

    return 0;
}


void la(const std::vector<BasicBlock*>& bbs)
{
	std::vector<std::set<std::string>> prev_ins(bbs.size(),{""});
	std::vector<std::set<std::string>> curr_ins(bbs.size(),{""});
	
	bool in_changed = true;
	while(in_changed) {
		for (int i=0; i<bbs.size(); i++) {
			if (bbs[i]->getID() != exit_id) {
				auto out = bbs[i]->out_bb();
				auto in = bbs[i]->in_bb();
				curr_ins[i] = in;
			}
		}	
		in_changed = !(std::equal(prev_ins.cbegin(), prev_ins.cend(),
					curr_ins.cbegin()));

		// FIXME(mene, ne kod :-) ) debil zaboravio da azurira prethodne in-ove
		// plus jos milion drugih glupljih gresaka, ali da
		prev_ins = curr_ins;
	}
}

